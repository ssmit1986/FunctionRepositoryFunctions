(* Wolfram Language Package *)

BeginPackage["FunctionRepo`OpenTestWritingPalette`", {"FunctionRepo`", "CodeFormatter`", "MUnit`"}]
(* Exported symbols added here with SymbolName::usage *)
GeneralUtilities`SetUsage[OpenTestWritingPalette,
	"OpenTestWritingPalette[] creates a palette with buttons that make writing tests easier."
];

Begin["`Private`"] (* Begin Private Context *)

OpenTestWritingPalette[] := OpenTestWritingPalette[
	Function[CreateUUID["Test-"]]
];

OpenTestWritingPalette[fun_] := CreatePalette[
	DynamicModule[{
		idFun = fun,
		nb, successQ = Null,
		data = "", time = SessionTime[],
		resetTime = 2,
		file = ""
	},
		Grid[
			Function[Transpose @ PadRight[#, Automatic, SpanFromAbove]] @ {
				Join[
					{
						Tooltip[FileNameSetter[Dynamic[file]],
							Dynamic[Replace[file, Except[_?FileExistsQ] :> "Select output file"]]
						]
					},
					Map[
						copyCellsAsTestStringButton[
							Dynamic[{nb, successQ, data, time, file}],
							#,
							idFun
						]&,
						{"Copy", "CopyAndPrint", "Convert", "CopyAndWrite"}
					],
					{
						Button[
							"Paste most recent tests",
							Paste[data],
							Enabled -> Dynamic[data =!= ""]
						],
						Button[
							"Write most recent tests",
							successQ = !FailureQ[appendStringToFile[file, data]];
							time = SessionTime[],
							Enabled -> Dynamic[data =!= "" && FileExistsQ[file]]
						]
					}
				],
				{
					Item[
						DynamicWrapper[
							PaneSelector[
								{
									False -> Tooltip[Style["\[Times]", Red, Bold, 24], "Could not find valid input"]
								},
								Dynamic[successQ],
								""
							],
							If[ TrueQ[time + resetTime < SessionTime[]],
								successQ = Null
							],
							UpdateInterval -> 1.,
							TrackedSymbols :> {}
						],
						Alignment -> {Left, Center}
					]
				}
			}
		]
	],
	Saveable -> False,
	WindowTitle -> "Test writing tools"
];

appendStringToFile[file_String?FileExistsQ, str_String] := Quiet @ Module[{stream},
	WithCleanup[
		stream = OpenAppend[file],
		If[ !FailureQ[stream],
			Quiet @ Check[WriteString[stream, str <> "\n\n"], $Failed],
			$Failed
		],
		Close[stream]
	]
];
appendStringToFile[___] := $Failed;

inputOutputGroupPattern = Alternatives[
	Cell[
		CellGroupData[{Cell[_, "Input", ___], ___Cell, Cell[_, "Output", ___]}, _]
	],
	Cell[
		CellGroupData[{Cell[_, "VerificationTest", ___], ___Cell, Cell[_, "BottomCell", ___]}, _]
	]
];

addCellIDs[cells_] := Replace[
	cells,
	Cell[
		fst_, style_String,
		rest___
	] /; !MemberQ[{rest}, CellID -> _] :> Cell[fst, style, rest, CellID -> RandomInteger[1*^8]],
	{4}
];

getCells[] := getCells[InputNotebook[]];
getCells[nb_] := Module[{
	read = NotebookRead[nb]
},
	Enclose[
		ConfirmAssert[Head[read] =!= NotebookRead];
		read = Cases[read, inputOutputGroupPattern, {0, Infinity}];
		If[ read === {},
			SelectionMove[InputNotebook[], All, CellGroup];
			read = NotebookRead[nb];
			read = Cases[read, inputOutputGroupPattern, {0, Infinity}]
		];
		ConfirmMatch[read, {inputOutputGroupPattern..}];
		addCellIDs[read]
	]
];

addRule[HoldComplete[r1_Rule], r2_] := addRule[HoldComplete[{r1}], r2];
addRule[Except[HoldComplete[_]], rule_] := addRule[HoldComplete[{}], rule];
addRule[
	HoldComplete[{r___Rule}],
	(Rule | RuleDelayed)[key_, val_]
] /; FreeQ[Keys[Unevaluated[{r}]], key] := With[{
	eval = val
},
	HoldComplete[{r, key -> eval}]
];
addRule[rules : HoldComplete[{___Rule}], _] := rules;

addTestId[None][cells_] := cells;
addTestId[idFun_][cells_] := ReplaceAll[cells,
	CellGroupData[
		{
			input : Cell[__, "VerificationTest", ___],
			other___,
			bottom : Cell[__, "BottomCell", ___]
		},
		last_
	] :> With[{
		allRules = addRule[
			FirstCase[{other},
				Cell[boxes_, ___, "TestOptions", ___] :> With[{
					expr = MakeExpression[boxes, StandardForm]
				},
					expr /; MatchQ[expr, HoldComplete[_Rule | {___Rule}]]
				]
			],
			TestID :> ToString[idFun[]]
		]
	},
		CellGroupData[
			{
				input,
				Sequence @@ DeleteCases[{other},
					Cell[__, "TestOptions", ___]
				],
				Cell[
					BoxData[MakeBoxes @@ allRules],
					"TestOptions"
				],
				bottom
			},
			last
		]
	]
];

cellsToStrings[read_List, idFun_] := Module[{
	str
},
	Enclose[
		Block[{$Context, $ContextPath}, Needs["MUnit`"]];
		ConfirmMatch[read, {inputOutputGroupPattern..}];
		str = Catch[
			Quiet[
				MUnit`Notebooks`Private`cellsToTestsString[
					addTestId[idFun] @ MUnit`Palette`Private`convertCells[read]
				]
			],
			MUnit`MUnitErrorTag,
			Function[$Failed]
		];
		ConfirmBy[str, StringQ[#] && SyntaxQ[#]&];
		str = StringDelete[
			StringTrim[str],
			"(*" ~~ Shortest[___] ~~ "*)"
		];
		ConfirmMatch[
			ConfirmQuiet @ ToExpression[str, InputForm, HoldComplete],
			HoldComplete[_VerificationTest, (Null | _VerificationTest)...]
		];
		str
	]
];
cellsToStrings[el_] := cellsToStrings[{el}];

copyCellsAsTestStringButton[
	Dynamic[{nb_, successQ_, data_, time_, file_}],
	function : "Copy" | "CopyAndPrint" | "Convert" | "CopyAndWrite",
	idFun_
] := ReleaseHold @ Button[
	Replace[function,
		{
			"Copy" :> "Copy tests",
			"CopyAndPrint" :> "Create tests",
			"Convert" :> "Convert to tests",
			"CopyAndWrite" :> "Add tests to file"
		}
	],
	Evaluate @ Replace[
		Flatten @ Hold[
			nb = InputNotebook[],
			successQ = TrueQ @ Not[
				FailureQ @ Enclose[
					data = Confirm @ cellsToStrings[
						Confirm @ getCells[nb],
						idFun
					]
				]
			],
			Evaluate @ Replace[function,
				{
					"Copy" :> Hold[
						If[ successQ,
							CopyToClipboard[data]
						]
					],
					"CopyAndPrint" :> Hold[
						If[ successQ,
							SelectionMove[nb, After, CellGroup];
							Paste[data]
						]
					],
					"Convert" :> Hold[
						If[ successQ,
							NotebookDelete[nb];
							Paste[data]
						]
					],
					"CopyAndWrite" :> Hold[
						If[ successQ,
							successQ = !FailureQ[
								appendStringToFile[file, data]
							]
						]
					]
				}
			],
			time = SessionTime[]
		],
		Hold[args__] :> Hold[CompoundExpression[args]]
	],
	ImageSize -> Full,
	Evaluate @ If[ function === "CopyAndWrite",
		Enabled -> Dynamic[FileExistsQ[file]],
		Unevaluated[Sequence[]]
	]
];

End[] (* End Private Context *)

EndPackage[]
