(* Wolfram Language Package *)

BeginPackage["FunctionRepo`OpenTestWritingPalette`", {"FunctionRepo`", "CodeFormatter`", "MUnit`"}]
(* Exported symbols added here with SymbolName::usage *)
GeneralUtilities`SetUsage[OpenTestWritingPalette,
	"OpenTestWritingPalette[] creates a palette with buttons that make writing tests easier."
];

Begin["`Private`"] (* Begin Private Context *)

OpenTestWritingPalette[] := OpenTestWritingPalette[
	Function[CreateUUID["Test-"]]
];

OpenTestWritingPalette[idFun_] := CreatePalette[
	DynamicModule[{
		nb, successQ = Null,
		data, time,
		resetTime = 2
	},
		Grid[
			Function[Transpose @ PadRight[#, Automatic, SpanFromAbove]] @ {
				Map[
					copyCellsAsTestStringButton[
						Dynamic[{nb, successQ, data, time}],
						#,
						idFun
					]&,
					{"Copy", "CopyAndPrint", "Convert"}
				],
				{
					Item[
						DynamicWrapper[
							PaneSelector[
								{
									False -> Tooltip[Style["\[Times]", Red, Bold, 24], "Could not find valid input"]
								},
								Dynamic[successQ],
								""
							],
							If[ TrueQ[time + resetTime < SessionTime[]],
								successQ = Null
							],
							UpdateInterval -> 1.,
							TrackedSymbols :> {}
						],
						Alignment -> {Left, Center}
					]
				}
			}
		]
	],
	Saveable -> False,
	WindowTitle -> "Test writing tools"
];

inputOutputGroupPattern = Alternatives[
	Cell[
		CellGroupData[{Cell[_, "Input", ___], ___Cell, Cell[_, "Output", ___]}, _]
	],
	Cell[
		CellGroupData[{Cell[_, "VerificationTest", ___], ___Cell, Cell[_, "BottomCell", ___]}, _]
	]
];

addCellIDs[cells_] := Replace[
	cells,
	Cell[
		fst_, style_String,
		rest___
	] /; !MemberQ[{rest}, CellID -> _] :> Cell[fst, style, rest, CellID -> RandomInteger[1*^8]],
	{4}
];

getCells[] := getCells[InputNotebook[]];
getCells[nb_] := Module[{
	read = NotebookRead[nb]
},
	Enclose[
		ConfirmAssert[Head[read] =!= NotebookRead];
		read = Cases[read, inputOutputGroupPattern, {0, Infinity}];
		If[ read === {},
			SelectionMove[InputNotebook[], All, CellGroup];
			read = NotebookRead[nb];
			read = Cases[read, inputOutputGroupPattern, {0, Infinity}]
		];
		ConfirmMatch[read, {inputOutputGroupPattern..}];
		addCellIDs[read]
	]
];

addTestId[None][cells_] := cells;
addTestId[idFun_][cells_] := ReplaceAll[cells,
	CellGroupData[
		{
			input : Cell[__, "VerificationTest", ___],
			other___,
			bottom : Cell[__, "BottomCell", ___]
		},
		last_
	] :> CellGroupData[
		{
			input,
			other,
			Cell[
				BoxData @ ToBoxes[{TestID -> ToString[idFun[]]}],
				"TestOptions"
			],
			bottom
		},
		last
	]
];

cellsToStrings[read_List, idFun_] := Module[{
	str
},
	Enclose[
		ConfirmMatch[read, {inputOutputGroupPattern..}];
		str = Quiet[
			MUnit`Notebooks`Private`cellsToTestsString[
				addTestId[idFun] @ MUnit`Palette`Private`convertCells[read]
			]
		];
		ConfirmBy[str, StringQ[#] && SyntaxQ[#]&];
		str = StringDelete[
			StringTrim[str],
			"(*" ~~ Shortest[___] ~~ "*)"
		];
		ConfirmMatch[
			ConfirmQuiet @ ToExpression[str, InputForm, HoldComplete],
			HoldComplete[_VerificationTest, (Null | _VerificationTest)...]
		];
		str
	]
];
cellsToStrings[el_] := cellsToStrings[{el}];

copyCellsAsTestStringButton[
	Dynamic[{nb_, successQ_, data_, time_}],
	function : "Copy" | "CopyAndPrint" | "Convert",
	idFun_
] := ReleaseHold @ Button[
	Replace[function,
		{
			"Copy" :> "Copy tests",
			"CopyAndPrint" :> "Create tests",
			"Convert" :> "Convert to tests"
		}
	],
	Evaluate @ Replace[
		Flatten @ Hold[
			nb = InputNotebook[],
			successQ = TrueQ @ Not[
				FailureQ @ Enclose[
					data = Confirm @ cellsToStrings[
						Confirm @ getCells[nb],
						idFun
					]
				]
			],
			Evaluate @ Replace[function,
				{
					"Copy" :> Hold[
						If[ successQ,
							CopyToClipboard[data]
						]
					],
					"CopyAndPrint" :> Hold[
						If[ successQ,
							SelectionMove[nb, After, CellGroup];
							Paste[data]
						]
					],
					"Convert" :> Hold[
						If[ successQ,
							NotebookDelete[nb];
							Paste[data]
						]
					]
				}
			],
			time = SessionTime[]
		],
		Hold[args__] :> Hold[CompoundExpression[args]]
	],
	ImageSize -> Full
];

End[] (* End Private Context *)

EndPackage[]
