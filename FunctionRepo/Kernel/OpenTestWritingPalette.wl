(* Wolfram Language Package *)

BeginPackage["FunctionRepo`OpenTestWritingPalette`", {"FunctionRepo`", "CodeFormatter`", "MUnit`"}]
(* Exported symbols added here with SymbolName::usage *)
GeneralUtilities`SetUsage[OpenTestWritingPalette,
	"OpenTestWritingPalette[] creates a palette with buttons that make writing tests easier."
];

Begin["`Private`"] (* Begin Private Context *)

OpenTestWritingPalette[] := OpenTestWritingPalette[
	Function[CreateUUID["Test-"]]
];

OpenTestWritingPalette[fun_] := CreatePalette[
	DynamicModule[{
		idFun = fun,
		nb, successQ = Null,
		error = Null,
		data = "", time = SessionTime[],
		resetFlag = False,
		resetTime = 2,
		file = $Canceled,
		errorSymbol = Style["\[Times]", Red, Bold, 24],
		successSymbol = Style["\[Checkmark]", Green, Bold, 24]
	},
		Grid[
			Function[Transpose @ PadRight[#, Automatic, SpanFromAbove]] @ {
				Join[
					{
						"Output file selection",
						Row[{
							FileNameSetter[Dynamic[file], "Save", {"Wolfram test file" -> {"*.wlt", ".mt"}}],
							" ",
							Dynamic[
								Replace[file,
									{
										s_String :> Tooltip[FileNameTake[s], file],
										_ -> "No file selected"
									}
								],
								TrackedSymbols :> {file}
							]
						}],
						"",
						"Creating tests"
					},
					Map[
						copyCellsAsTestStringButton[
							Dynamic[{nb, successQ, error, data, file}],
							#,
							idFun
						]&,
						{"Copy", "CopyAndPrint", "Convert", "CopyAndWrite"}
					],
					{
						"",
						"Other utilities",
						(*Button[
							"Paste latest generated tests",
							Paste[data],
							Enabled -> Dynamic[data =!= ""]
						],
						Button[
							"Write latest generated tests",
							appendStringToFile[file, data, Dynamic[{successQ, error}]],
							Enabled -> Dynamic[data =!= "" && StringQ[file]]
						],
						Button[
							"Copy as plain text",
							FrontEndTokenExecute[SelectedNotebook[], "CopySpecial", "PlainText"]
						],*)
						Button[
							"Write selected cells to file",
							SelectionMove[InputNotebook[], All, Cell];
							Replace[
								FrontEndExecute[FrontEnd`ExportPacket[NotebookSelection[InputNotebook[]], "InputText"]],
								{
									{s_String, ___} :> (
										appendStringToFile[file, s, Dynamic[{successQ, error}]]
									),
									_ :> (
										successQ = False;
										error = "Failed to read input"
									)
								}
							],
							Enabled -> Dynamic[StringQ[file]]
						],
						Button[
							"Open output file",
							SystemOpen[file],
							Enabled -> Dynamic[StringQ[file]]
						],
						Button[
							"Paste output filename",
							Paste[ToString[file, InputForm]],
							Enabled -> Dynamic[StringQ[file]]
						]
					}
				],
				{
					Item[
						DynamicWrapper[
							PaneSelector[
								{
									False -> Tooltip[
										errorSymbol,
										Dynamic[Replace[error, Null -> "Unknown error"]]
									],
									True -> successSymbol
								},
								Dynamic[successQ],
								"",
								ImageSize -> All
							],
							If[ successQ =!= Null && resetFlag === False,
								time = SessionTime[];
								resetFlag = True
								,
								If[ TrueQ[time + resetTime < SessionTime[]],
									successQ = Null;
									error = Null;
									resetFlag = False
								]
							],
							UpdateInterval -> 1.,
							TrackedSymbols :> {successQ}
						],
						Alignment -> {Center, Center}
					]
				}
			}
		]
	],
	Saveable -> False,
	WindowTitle -> "Test writing tools"
];

appendStringToFile[file_String, str_String, Dynamic[{successQ_, error_}]] := Quiet @ Module[{stream},
	successQ = Not @ FailureQ @ WithCleanup[
		stream = OpenAppend[file],
		If[ !FailureQ[stream],
			Quiet @ Check[
				WriteString[
					stream,
					StringReplace[str <> "\n\n", "\r\n" -> "\n"]
				],
				$Failed
			],
			$Failed
		],
		Close[stream]
	];
	If[ Not[successQ],
		error = "Failed to write to file"
	]
];
appendStringToFile[file_, str_, Dynamic[{successQ_, error_}]] := (
	successQ = False;
	error = If[!StringQ[file],
		"No output file selected",
		"No cannot write this type of output"
	]
);

inputOutputGroupPattern = Alternatives[
	Cell[
		CellGroupData[{Cell[_, "Input", ___], ___Cell, Cell[_, "Output", ___]}, _]
	],
	Cell[
		CellGroupData[{Cell[_, "VerificationTest", ___], ___Cell, Cell[_, "BottomCell", ___]}, _]
	]
];

addCellIDs[cells_] := Replace[
	cells,
	Cell[
		fst_, style_String,
		rest___
	] /; !MemberQ[{rest}, CellID -> _] :> Cell[fst, style, rest, CellID -> RandomInteger[1*^8]],
	{4}
];

getCells[] := getCells[InputNotebook[]];
getCells[nb_] := Module[{
	read = NotebookRead[nb]
},
	Enclose[
		ConfirmAssert[Head[read] =!= NotebookRead];
		read = Cases[read, inputOutputGroupPattern, {0, Infinity}];
		If[ read === {},
			SelectionMove[InputNotebook[], All, CellGroup];
			read = NotebookRead[nb];
			read = Cases[read, inputOutputGroupPattern, {0, Infinity}]
		];
		ConfirmMatch[read, {inputOutputGroupPattern..}];
		addCellIDs[read]
	]
];

addRule[HoldComplete[r1_Rule], r2_] := addRule[HoldComplete[{r1}], r2];
addRule[Except[HoldComplete[_]], rule_] := addRule[HoldComplete[{}], rule];
addRule[
	HoldComplete[{r___Rule}],
	(Rule | RuleDelayed)[key_, val_]
] /; FreeQ[Keys[Unevaluated[{r}]], key] := With[{
	eval = val
},
	HoldComplete[{r, key -> eval}]
];
addRule[rules : HoldComplete[{___Rule}], _] := rules;

addTestId[None][cells_] := cells;
addTestId[idFun_][cells_] := ReplaceAll[cells,
	CellGroupData[
		{
			input : Cell[__, "VerificationTest", ___],
			other___,
			bottom : Cell[__, "BottomCell", ___]
		},
		last_
	] :> With[{
		allRules = addRule[
			FirstCase[{other},
				Cell[boxes_, ___, "TestOptions", ___] :> With[{
					expr = MakeExpression[boxes, StandardForm]
				},
					expr /; MatchQ[expr, HoldComplete[_Rule | {___Rule}]]
				]
			],
			TestID :> ToString[idFun[]]
		]
	},
		CellGroupData[
			{
				input,
				Sequence @@ DeleteCases[{other},
					Cell[__, "TestOptions", ___]
				],
				Cell[
					BoxData[MakeBoxes @@ allRules],
					"TestOptions"
				],
				bottom
			},
			last
		]
	]
];

cellsToStrings[read_List, idFun_] := Module[{
	str
},
	Enclose[
		Block[{$Context, $ContextPath}, Needs["MUnit`"]];
		ConfirmMatch[read, {inputOutputGroupPattern..}];
		str = Catch[
			Quiet[
				MUnit`Notebooks`Private`cellsToTestsString[
					addTestId[idFun] @ MUnit`Palette`Private`convertCells[read]
				]
			],
			MUnit`MUnitErrorTag,
			Function[$Failed]
		];
		ConfirmBy[str, StringQ[#] && SyntaxQ[#]&];
		str = StringDelete[
			StringTrim[str],
			"(*" ~~ Shortest[___] ~~ "*)"
		];
		ConfirmMatch[
			ConfirmQuiet @ ToExpression[str, InputForm, HoldComplete],
			HoldComplete[_VerificationTest, (Null | _VerificationTest)...]
		];
		str
	]
];
cellsToStrings[el_] := cellsToStrings[{el}];

copyCellsAsTestStringButton[
	Dynamic[{nb_, successQ_, error_, data_, file_}],
	function : "Copy" | "CopyAndPrint" | "Convert" | "CopyAndWrite",
	idFun_
] := ReleaseHold @ Button[
	Replace[function,
		{
			"Copy" :> "Copy tests",
			"CopyAndPrint" :> "Create tests",
			"Convert" :> "Convert to tests",
			"CopyAndWrite" :> "Add tests to file"
		}
	],
	Evaluate @ Replace[
		Flatten @ Hold[
			nb = InputNotebook[],
			successQ = TrueQ @ Not[
				FailureQ @ Enclose[
					data = Confirm @ cellsToStrings[
						Confirm @ getCells[nb],
						idFun
					]
				]
			],
			Evaluate @ Replace[function,
				{
					"Copy" :> Hold[
						If[ successQ,
							CopyToClipboard[data]
							,
							error = "Could not find valid input"
						]
					],
					"CopyAndPrint" :> Hold[
						If[ successQ,
							SelectionMove[nb, After, CellGroup];
							Paste[data]
							,
							error = "Could not find valid input"
						]
					],
					"Convert" :> Hold[
						If[ successQ,
							NotebookDelete[nb];
							Paste[data]
							,
							error = "Could not find valid input"
						]
					],
					"CopyAndWrite" :> Hold[
						If[ successQ,
							appendStringToFile[file, data, Dynamic[{successQ, error}]]
							,
							error = "Could not find valid input"
						]
					]
				}
			]
		],
		Hold[args__] :> Hold[CompoundExpression[args]]
	],
	ImageSize -> Full,
	Evaluate @ If[ function === "CopyAndWrite",
		Enabled -> Dynamic[StringQ[file]],
		Unevaluated[Sequence[]]
	]
];

End[] (* End Private Context *)

EndPackage[]
